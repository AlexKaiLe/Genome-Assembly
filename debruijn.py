import sys
import numpy as np
import graphviz
import networkx as nx
sys.setrecursionlimit(10000)

START_END = [] 

'''Obtains the inputs from command line'''
def obtain_inputs():
    try:
        # Checks for valid inputs 
        reads = sys.argv[1] 

        # obtain the sequences and scoring matrix from the files
        with open(reads) as file:
            lines = file.readlines()
            reads = [line.rstrip().upper() for line in lines]
            file.close()
        # return reads
        output = sorted(list(set(reads)))
        return output
    except:
        return None

'''Obtain the prefix and suffix of reads'''
def pre_suf(reads):
    read_dict = []
    for read in reads:
        pre = read[:-1]
        suf = read[1:]
        read_dict.append([pre, suf, read])
    return np.array(read_dict)

'''Function that helps conctat consecutive words'''
def help_fnc(i, j):
    for ele in range(len(j), -1, -1):
        if i.endswith(j[:ele]):
            return j[ele:]

'''Concat a list of words to obtian a string'''
def concat(test_list):
    return ''.join(help_fnc(i, j) for i, j in zip([''] + test_list, test_list))

'''Determine if the target seq is in a list of seq and find the location'''
def exist(target, seq):
    count = 0
    index = []
    for i in range(len(seq)):
        if seq[i].startswith(target):
            count += 1
            index.append(i)
    return count, index

'''Simplify the graph by looking at outgoing and incoming edges to nodes'''
def simplify(node_edge):
    reduced = list(node_edge)
    i = 0 
    while i < len(reduced):
        prefix = np.array(reduced)[:,0]
        suffix = np.array(reduced)[:,1]

        pre_in_suffix, pre_suf_loc = exist(reduced[i][0], suffix)
        pre_in_prefix, pre_pre_loc = exist(reduced[i][0], prefix)
        suf_in_suffix, suf_suf_loc = exist(reduced[i][1], suffix)
        suf_in_prefix, suf_pre_loc = exist(reduced[i][1], prefix)

        if (pre_in_prefix <= 1 and suf_in_suffix <= 1):
            # reduced[i] = [reduced[i][0], reduced[i][1], "*" + reduced[i][2]]
            for j in suf_pre_loc:
                reduced[j] = [reduced[i][2], reduced[j][1], concat([reduced[i][2], reduced[j][1]])]
            for j in pre_suf_loc:
                reduced[j] = [reduced[j][0], reduced[i][2], concat([reduced[j][0], reduced[i][2]])]
            
            if len(suf_pre_loc) == 0 and len(pre_suf_loc) == 0:
                reduced.append(["","",reduced[i][2]])
            reduced.pop(i)
            i = 0
        else:
            i += 1
    return reduced


'''Get the paths generated by the graph'''
def get_paths(node_edge):
    graph = {}
    ids = {}
    id = 0
    # create a dictory that represents the graph
    for i in node_edge:
        if i[0] not in graph:
            graph[i[0]] = [i[1]]
        else:
            graph[i[0]].append(i[1])

        if i[0] not in ids:
            ids[i[0]] = id
            id += 1

    prefix = np.array(node_edge)[:,0]
    suffix = np.array(node_edge)[:,1]
    
    start = [pre for pre in prefix if len(np.where(pre == suffix)[0]) == 0]
    end = [suf for suf in suffix if len(np.where(suf == prefix)[0]) == 0]
    
    # add nodes that are sinks to the graph
    for i in end:
        if i not in graph:
            graph[i] = [""]
        if i not in ids:
            ids[i] = id
            id += 1

    # find all paths from the start nodes to the end nodes
    count = 0
    for i in start:
        count += 1
        for j in end:
            visited =[False]*len(graph)
            paths(i, j, visited, [], graph, ids, node_edge)

    all_paths = []
    for i in START_END:
        all_paths.append(i.split(","))
    
    # Obtain the sequences of the paths
    optimal_paths = []
    if len(all_paths) != 0:
        best_path, length = [], []
        for i in all_paths:
            seq = get_seq(i)
            # seq = concat(i)
            if seq not in best_path:
                best_path.append(seq)
                length.append(len(seq))
        longest = max(length)
        # find the longest path
        for j in sorted(best_path):
            if len(j) == longest:
                print(j)
                optimal_paths.append(j)
        return optimal_paths
    else:
        print("ERROR: The graph you have created has no start/ending node")
        return None
        

'''Obtain the sequence from list'''
def get_seq(seq):
    output = seq[0]
    for i in range(1, len(seq)):
        output += seq[i][-1]
    return output

'''Recursive function that finds all the paths from point A to point B'''
def paths(u, d, visited, path, graph, ids, node_edge): 
    visited[ids[u]]= True
    path.append(str(u))

    if u == d: 
        START_END.append(",".join(path))
    else: 
        for i in graph[u]: 
            if i in ids and visited[ids[i]]==False: 
                paths(i, d, visited, path, graph, ids, node_edge) 
                    
    # remove current vertex and mark as unvisited
    path.pop() 
    visited[ids[u]]= False

'''Application method with modifications'''
def application(reads):
    reads = sorted(list(set(reads)))
    node_edge = pre_suf(reads)
    node_edge = simplify(node_edge)
    return get_paths(node_edge)

'''Main method'''
def main():
    dot = graphviz.Digraph()
    reads = obtain_inputs()
    node_edge = pre_suf(reads)
    optimal_paths = get_paths(node_edge)
    if len(reads) > 2:
        node_edge = simplify(node_edge)
        for elem in node_edge:
            if elem[0] == "":
                dot.node(elem[2])
            else:
                dot.edge(elem[0], elem[1], elem[2])
    else:
        dot.edge(reads[0], reads[1], optimal_paths[0])
    

    dot.render(filename="debruijn", view = True)

if __name__ == "__main__":
    try:
        main()
    except:
        print("Error: something went wrong in the program")

